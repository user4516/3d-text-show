<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Pragma" content="no-cache">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,viewport-fit=cover">
  <title>祝你前程似锦~</title>
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
    }
    body { 
      overflow: hidden; 
      background: #000; 
      touch-action: manipulation;
      font-family: "Microsoft Yahei", PingFang SC, sans-serif;
    }
    #container { 
      width: 100vw; 
      height: 100vh; 
    }
    /* 加载提示样式 */
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 18px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .loading-progress {
      font-size: 14px;
      color: #ccc;
    }
    #webgl-error {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      text-align: center;
      z-index: 9999;
      display: none;
    }
    #webgl-error p {
      margin-top: 20px;
      line-height: 1.6;
    }
  </style>
  <!-- 第一步：内联极简Three.js核心（兜底方案） -->
  <script>
    // 极简Three.js核心兜底（仅保留必要功能，无外部依赖）
    if (!window.THREE) {
      window.THREE = {
        Scene: function() {
          this.children = [];
          this.add = function(obj) { this.children.push(obj); };
          this.remove = function(obj) { 
            const idx = this.children.indexOf(obj);
            if (idx > -1) this.children.splice(idx, 1);
          };
        },
        PerspectiveCamera: function(fov, aspect, near, far) {
          this.fov = fov;
          this.aspect = aspect;
          this.near = near;
          this.far = far;
          this.position = { x: 0, y: 0, z: 0 };
          this.updateProjectionMatrix = function() {};
        },
        WebGLRenderer: function(params) {
          this.domElement = document.createElement('canvas');
          this.setSize = function(w, h) {
            this.domElement.width = w;
            this.domElement.height = h;
          };
          this.setPixelRatio = function() {};
          this.render = function(scene, camera) {
            const ctx = this.domElement.getContext('webgl') || this.domElement.getContext('experimental-webgl');
            if (ctx) {
              ctx.clearColor(0, 0, 0, 1);
              ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);
            }
          };
        },
        MeshBasicMaterial: function(params) {
          this.map = params.map;
          this.color = params.color || { r: 1, g: 1, b: 1 };
          this.transparent = params.transparent;
          this.opacity = params.opacity;
          this.side = params.side;
          this.alphaTest = params.alphaTest;
          this.blending = params.blending;
          this.needsUpdate = false;
        },
        PlaneGeometry: function(w, h) {
          this.dispose = function() {};
          this.clone = function() { return new THREE.PlaneGeometry(w, h); };
        },
        Mesh: function(geo, mat) {
          this.geometry = geo;
          this.material = mat;
          this.position = { x: 0, y: 0, z: 0 };
          this.userData = {};
        },
        CanvasTexture: function(canvas) {
          this.image = canvas;
          this.minFilter = 1003;
          this.magFilter = 1003;
          this.needsUpdate = false;
          this.dispose = function() {};
        },
        Color: function(r, g, b) {
          if (typeof r === 'number') {
            this.r = r;
            this.g = g;
            this.b = b;
          } else {
            this.r = 1; this.g = 1; this.b = 1;
          }
          this.setRGB = function(r, g, b) {
            this.r = r; this.g = g; this.b = b;
          };
          this.clone = function() {
            return new THREE.Color(this.r, this.g, this.b);
          };
          this.copy = function(color) {
            this.r = color.r; this.g = color.g; this.b = color.b;
          };
        },
        AmbientLight: function(color, intensity) {},
        BufferGeometry: function() {
          this.setAttribute = function() {};
        },
        BufferAttribute: function(arr, itemSize) {},
        PointsMaterial: function(params) {},
        Points: function(geo, mat) {},
        DoubleSide: 2,
        LinearFilter: 1003,
        NormalBlending: 1
      };
    }
  </script>
  <!-- 第二步：多CDN加载Three.js（主方案） -->
  <script>
    // 定义多个备用CDN链接
    const threeCDNs = [
      'https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.140.0/three.min.js',
      'https://unpkg.com/three@0.140.0/build/three.min.js'
    ];
    const orbitCDNs = [
      'https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js',
      'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.140.0/examples/js/controls/OrbitControls.js',
      'https://unpkg.com/three@0.140.0/examples/js/controls/OrbitControls.js'
    ];

    // 动态加载脚本函数
    function loadScript(url, timeout = 15000) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.defer = true;

        const timer = setTimeout(() => {
          script.remove();
          reject(new Error(`加载超时: ${url}`));
        }, timeout);

        script.onload = () => {
          clearTimeout(timer);
          resolve();
        };

        script.onerror = () => {
          clearTimeout(timer);
          reject(new Error(`加载失败: ${url}`));
        };

        document.head.appendChild(script);
      });
    }

    // 重试加载函数（轮询CDN）
    async function loadWithRetry(cdnList, maxRetries = 3) {
      let lastError;
      for (let i = 0; i < Math.min(maxRetries, cdnList.length); i++) {
        try {
          await loadScript(cdnList[i], 15000);
          return true;
        } catch (e) {
          lastError = e;
          console.warn(`CDN ${i+1} 失败:`, e.message);
        }
      }
      throw lastError || new Error('所有CDN加载失败');
    }

    // 预加载Three.js核心
    window.preloadThree = async function() {
      try {
        // 先加载Three.js核心
        await loadWithRetry(threeCDNs);
        // 再加载OrbitControls
        try {
          await loadWithRetry(orbitCDNs);
        } catch (e) {
          console.warn('OrbitControls加载失败，使用内置简化版');
          window.OrbitControls = window.OrbitControls || {
            prototype: { update: function() {} },
            constructor: function(camera, dom) {
              this.enableDamping = false;
              this.update = function() {};
            }
          };
        }
        return true;
      } catch (e) {
        console.warn('所有CDN加载失败，使用内置极简版Three.js');
        return true; // 兜底方案已存在，返回true继续执行
      }
    };
  </script>
  <!-- 微信JS（非必需，不影响核心功能） -->
  <script src="https://res2.wx.qq.com/open/js/jweixin-1.6.0.js" onerror="console.warn('微信JS加载失败')"></script>
</head>
<body>
  <div id="loading">
    <div class="loading-spinner"></div>
    <div class="loading-text">正在加载3D场景...</div>
    <div class="loading-progress">0%</div>
  </div>
  <div id="webgl-error">
    <h3>加载失败</h3>
    <p>请检查网络后刷新页面，或更换浏览器重试</p>
    <p id="error-detail"></p>
  </div>
  <div id="container"></div>

  <!-- 1. 微信字体适配 -->
  <script>
    (function() {
      function handleFontSize() {
        try {
          if (window.WeixinJSBridge) {
            WeixinJSBridge.invoke("setFontSizeCallback", { fontSize: 0 });
            WeixinJSBridge.on("menu:setfont", () => {
              WeixinJSBridge.invoke("setFontSizeCallback", { fontSize: 0 });
            });
          }
        } catch (e) { /* 非微信环境忽略报错 */ }
      }

      if (window.WeixinJSBridge) {
        handleFontSize();
      } else {
        document.addEventListener("WeixinJSBridgeReady", handleFontSize, false);
      }
    })();
  </script>

  <!-- 2. 触控优化 -->
  <script>
    window.onload = function() {
      // 阻止多点触控
      document.addEventListener("touchstart", (event) => {
        if (event.touches.length > 2) event.preventDefault();
      }, { passive: false });

      // 阻止双击缩放
      let lastTouchEnd = 0;
      document.addEventListener("touchend", (event) => {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) event.preventDefault();
        lastTouchEnd = now;
      }, { passive: false });
    };
  </script>

  <!-- 3. 核心3D逻辑（加快上移速度版） -->
  <script>
    // 性能优化：全局节流函数
    function throttle(fn, delay) {
      let timer = null;
      return function(...args) {
        if (!timer) {
          timer = setTimeout(() => {
            fn.apply(this, args);
            timer = null;
          }, delay);
        }
      };
    }

    // 核心逻辑封装
    async function init3D() {
      // 核心变量
      let scene, camera, renderer, controls;
      const textMeshes = []; // 活跃文字列表
      const textList = ["学业有成", "步履不停", "奔赴山海", "未来可期", "前程似锦"];
      let currentRGB = { r: 255, g: 0, b: 0 }; // 全局统一RGB（数值型）
      let colorPhase = 0; 
      // 颜色统一：缓存全局颜色字符串，避免重复计算
      let globalColorStr = `rgb(${currentRGB.r}, ${currentRGB.g}, ${currentRGB.b})`;
      let globalThreeColor = new THREE.Color(currentRGB.r / 255, currentRGB.g / 255, currentRGB.b / 255);

      // 性能优化：设备性能检测
      const isLowEndDevice = /Android [1-8]|iPhone [4-8]|iPad [1-5]|Mobile Safari\/[1-9]/.test(navigator.userAgent) || 
                            screen.width < 768 && window.devicePixelRatio === 1;

      // 核心配置（加快上移速度：速度值翻倍）
      const baseConfig = {
        // 文字分布
        centerRatio: 0.8,
        centerXRange: { min: -25, max: 25 },
        sideXRange: { min: -50, max: 50 },
        zRange: { min: -50, max: 10 },
        // 持续刷新（性能优化：低配设备减少数量）
        maxActiveText: isLowEndDevice ? 50 : 80,
        minActiveText: isLowEndDevice ? 45 : 75,
        spawnInterval: isLowEndDevice ? 80 : 50,
        deleteYThreshold: 120, // 提高删除阈值，避免文字消失太快
        // 字体大小（低配设备缩小尺寸）
        fontSize: {
          small: { min: isLowEndDevice ? 40 : 50, max: isLowEndDevice ? 70 : 80, weight: 0.6 },
          medium: { min: isLowEndDevice ? 70 : 80, max: isLowEndDevice ? 100 : 110, weight: 0.3 },
          large: { min: isLowEndDevice ? 100 : 110, max: isLowEndDevice ? 130 : 140, weight: 0.1 }
        },
        // 几何尺寸（匹配字体大小）
        geoSize: {
          small: { min: isLowEndDevice ? 10 : 15, max: isLowEndDevice ? 25 : 30, weight: 0.6 },
          medium: { min: isLowEndDevice ? 25 : 30, max: isLowEndDevice ? 35 : 40, weight: 0.3 },
          large: { min: isLowEndDevice ? 35 : 40, max: isLowEndDevice ? 45 : 50, weight: 0.1 }
        },
        // 速度配置（核心修改：速度值翻倍，加快上移）
        centerSpeedRange: { min: isLowEndDevice ? 0.30 : 0.60, max: isLowEndDevice ? 0.30 : 0.60 }, // 原0.04/0.09 → 0.08/0.18；0.03/0.08 → 0.06/0.16
        sideSpeedRange: { min: isLowEndDevice ? 0.25 : 0.20, max: isLowEndDevice ? 0.20 : 0.25 },   // 原0.06/0.11 → 0.12/0.22；0.05/0.10 → 0.10/0.20
        // 颜色渐变（低配设备降低渐变速度，减少计算）
        colorSpeed: isLowEndDevice ? 0.002 : 0.004
      };
      const config = baseConfig;

      // 加载相关变量
      const loadingEl = document.getElementById('loading');
      const loadingTextEl = loadingEl.querySelector('.loading-text');
      const loadingProgressEl = loadingEl.querySelector('.loading-progress');
      const webglErrorEl = document.getElementById('webgl-error');
      const errorDetailEl = document.getElementById('error-detail');
      let loadProgress = 0;
      const loadTimeout = 20000; // 延长超时时间

      // 颜色渐变表（数值型RGB）
      const colorGradients = [
        { r: 255, g: 0, b: 0 },    // 红
        { r: 255, g: 127, b: 0 }, // 橙
        { r: 255, g: 255, b: 0 }, // 黄
        { r: 0, g: 255, b: 0 },    // 绿
        { r: 0, g: 255, b: 255 }, // 青
        { r: 0, g: 0, b: 255 },    // 蓝
        { r: 127, g: 0, b: 255 }, // 紫
        { r: 255, g: 0, b: 0 }     // 红（闭环）
      ];

      // 检测WebGL支持
      function checkWebGL() {
        try {
          const canvas = document.createElement('canvas');
          return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
        } catch (e) {
          return false;
        }
      }

      // 更新加载进度
      function updateLoadProgress(progress) {
        loadProgress = Math.min(progress, 100);
        loadingProgressEl.textContent = `${loadProgress}%`;
        if (loadProgress >= 100) {
          loadingEl.style.opacity = 0;
          loadingEl.style.transition = 'opacity 0.5s ease';
          setTimeout(() => {
            loadingEl.style.display = 'none';
          }, 500);
        }
      }

      // 生成偏向中心的X坐标（更密集）
      function getCenterBiasedX(isCenter) {
        if (isCenter) {
          return Math.random() * (config.centerXRange.max - config.centerXRange.min) + config.centerXRange.min;
        } else {
          const sideX = Math.random() * (config.sideXRange.max - config.sideXRange.min) + config.sideXRange.min;
          if (sideX > config.centerXRange.min && sideX < config.centerXRange.max) {
            return sideX < 0 ? config.centerXRange.min - 3 : config.centerXRange.max + 3;
          }
          return sideX;
        }
      }

      // 按权重随机选择尺寸类型（小字60%、中字30%、大字10%）
      function getSizeType() {
        const random = Math.random();
        if (random < config.fontSize.small.weight) {
          return 'small';
        } else if (random < config.fontSize.small.weight + config.fontSize.medium.weight) {
          return 'medium';
        } else {
          return 'large';
        }
      }

      // 生成随机字号（按尺寸类型权重）
      function getRandomFontSize() {
        const sizeType = getSizeType();
        const range = config.fontSize[sizeType];
        return Math.floor(Math.random() * (range.max - range.min + 1) + range.min);
      }

      // 生成随机几何尺寸（按尺寸类型权重）
      function getRandomGeoSize() {
        const sizeType = getSizeType();
        const range = config.geoSize[sizeType];
        return Math.round(Math.random() * (range.max - range.min) * 10) / 10 + range.min;
      }

      // 生成随机速度（关联文字大小：大字慢，小字快）
      function getRandomSpeed(isCenter, geoSize) {
        const speedFactor = 1 - (geoSize - config.geoSize.small.min) / (config.geoSize.large.max - config.geoSize.small.min);
        let baseMin, baseMax;
        if (isCenter) {
          baseMin = config.centerSpeedRange.min;
          baseMax = config.centerSpeedRange.max;
        } else {
          baseMin = config.sideSpeedRange.min;
          baseMax = config.sideSpeedRange.max;
        }
        return baseMin + (baseMax - baseMin) * speedFactor * Math.random();
      }

      // 通用随机函数（优化初始位置，更密集）
      function getRandomZ() { return Math.random() * (config.zRange.max - config.zRange.min) + config.zRange.min; }
      function getRandomY() { return Math.random() * -200; }
      function getRandomText() { return textList[Math.floor(Math.random() * textList.length)]; }
      function isCenterText() { return Math.random() < config.centerRatio; }

      // 颜色统一核心：更新全局颜色（同步字符串和Three.Color对象）
      function updateGlobalRGB() {
        colorPhase += config.colorSpeed;
        if (colorPhase > 1) colorPhase = 0;
        
        const gradientIndex = Math.floor(colorPhase * (colorGradients.length - 1));
        const nextIndex = (gradientIndex + 1) % (colorGradients.length - 1);
        const blend = (colorPhase * (colorGradients.length - 1)) - gradientIndex;
        
        const from = colorGradients[gradientIndex];
        const to = colorGradients[nextIndex];
        
        // 统一更新全局RGB值
        currentRGB.r = Math.floor(from.r + blend * (to.r - from.r));
        currentRGB.g = Math.floor(from.g + blend * (to.g - from.g));
        currentRGB.b = Math.floor(from.b + blend * (to.b - from.b));
        
        // 缓存颜色字符串和Three.Color对象（避免重复计算）
        globalColorStr = `rgb(${currentRGB.r}, ${currentRGB.g}, ${currentRGB.b})`;
        globalThreeColor.setRGB(currentRGB.r / 255, currentRGB.g / 255, currentRGB.b / 255);
      }

      // 性能优化：缓存文字纹理（避免重复创建画布）+ 颜色统一
      const textureCache = new Map();
      function getCachedTextTexture(text, fontSize) {
        const cacheKey = `${text}_${fontSize}`;
        if (textureCache.has(cacheKey)) {
          const textureData = textureCache.get(cacheKey);
          // 颜色统一：更新缓存纹理的颜色（使用全局颜色）
          const { ctx, canvas } = textureData;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.font = `bold ${fontSize}px Microsoft Yahei`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = globalColorStr;
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          textureData.texture.needsUpdate = true;
          return textureData;
        }
        
        const canvasWidth = fontSize * text.length * 2.2;
        const canvasHeight = fontSize * 2.8;
        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        
        // 颜色统一：初始化使用全局颜色
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold ${fontSize}px Microsoft Yahei`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = globalColorStr;
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        
        const textureData = { texture, canvas, ctx, cacheKey };
        textureCache.set(cacheKey, textureData);
        
        // 性能优化：缓存上限（避免内存溢出）
        if (textureCache.size > 50) {
          const oldestKey = Array.from(textureCache.keys())[0];
          const oldestData = textureCache.get(oldestKey);
          oldestData.texture.dispose();
          textureCache.delete(oldestKey);
        }
        
        return textureData;
      }

      // 性能优化：复用几何体（避免重复创建）
      const geoCache = new Map();
      function getReusableGeometry(width, height) {
        const cacheKey = `${width}_${height}`;
        if (geoCache.has(cacheKey)) {
          return geoCache.get(cacheKey).clone();
        }
        
        const geometry = new THREE.PlaneGeometry(width, height);
        geoCache.set(cacheKey, geometry);
        
        // 缓存上限
        if (geoCache.size > 20) {
          const oldestKey = Array.from(geoCache.keys())[0];
          geoCache.get(oldestKey).dispose();
          geoCache.delete(oldestKey);
        }
        
        return geometry;
      }

      // 创建单个文字（性能优化+颜色统一版）
      function createSingleText() {
        const isCenter = isCenterText();
        const text = getRandomText();
        const fontSize = getRandomFontSize();
        const geoWidth = getRandomGeoSize();
        const geoHeight = geoWidth / 4;

        try {
          // 颜色统一：使用带全局颜色的缓存纹理
          const textureData = getCachedTextTexture(text, fontSize);

          const material = new THREE.MeshBasicMaterial({
            map: textureData.texture,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide,
            alphaTest: 0.01,
            blending: THREE.NormalBlending,
            precision: "highp"
          });

          // 性能优化：复用几何体
          const geometry = getReusableGeometry(geoWidth, geoHeight);
          const mesh = new THREE.Mesh(geometry, material);
          
          mesh.position.set(
            getCenterBiasedX(isCenter),
            getRandomY(),
            getRandomZ()
          );
          
          mesh.userData = {
            isCenter: isCenter,
            speed: getRandomSpeed(isCenter, geoWidth),
            text: text,
            canvas: textureData.canvas,
            ctx: textureData.ctx,
            fontSize: fontSize,
            geoWidth: geoWidth,
            geoHeight: geoHeight,
            cacheKey: textureData.cacheKey
          };

          scene.add(mesh);
          textMeshes.push(mesh);
          return mesh;
        } catch (e) {
          // 兜底方块（颜色统一版）
          const geoWidth = getRandomGeoSize();
          const geoHeight = geoWidth / 4;
          const geometry = getReusableGeometry(geoWidth, geoHeight);
          const material = new THREE.MeshBasicMaterial({
            // 颜色统一：使用全局Three.Color对象
            color: globalThreeColor.clone(),
            transparent: true,
            opacity: 1,
            blending: THREE.NormalBlending,
            precision: "highp"
          });
          const mesh = new THREE.Mesh(geometry, material);
          
          mesh.position.set(
            getCenterBiasedX(isCenter),
            getRandomY(),
            getRandomZ()
          );
          
          mesh.userData = {
            isCenter: isCenter,
            speed: getRandomSpeed(isCenter, geoWidth),
            text: text,
            fontSize: fontSize,
            geoWidth: geoWidth,
            geoHeight: geoHeight
          };
          
          scene.add(mesh);
          textMeshes.push(mesh);
          return mesh;
        }
      }

      // 性能优化：节流生成文字，避免短时间大量创建
      const throttledSpawnNewText = throttle(() => {
        const needAdd = config.maxActiveText - textMeshes.length;
        if (needAdd > 0) {
          const addCount = Math.min(needAdd, isLowEndDevice ? 3 : 8);
          for (let i = 0; i < addCount; i++) {
            createSingleText();
          }
        }
      }, config.spawnInterval);

      // 删除指定文字（释放资源，性能优化：批量清理）
      function deleteText(mesh) {
        const index = textMeshes.indexOf(mesh);
        if (index > -1) {
          textMeshes.splice(index, 1);
          scene.remove(mesh);
          
          // 释放资源
          if (mesh.geometry) mesh.geometry.dispose();
          if (mesh.material) {
            if (mesh.material.map) {
              // 仅清理非缓存纹理
              if (!textureCache.has(mesh.userData.cacheKey)) {
                mesh.material.map.dispose();
              }
            }
            mesh.material.dispose();
          }
        }
      }

      // 性能优化：批量删除超出阈值的文字
      function batchDeleteText() {
        const toDelete = [];
        for (let i = textMeshes.length - 1; i >= 0; i--) {
          if (textMeshes[i].position.y > config.deleteYThreshold) {
            toDelete.push(textMeshes[i]);
          }
        }
        toDelete.forEach(deleteText);
      }

      // 初始化3D场景
      function initScene() {
        updateLoadProgress(20);
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        updateLoadProgress(30);
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 60);

        updateLoadProgress(40);
        // 性能优化：渲染器核心优化
        const rendererParams = {
          antialias: !isLowEndDevice, // 低配设备关闭抗锯齿
          alpha: false,
          powerPreference: "high-performance",
          precision: isLowEndDevice ? "mediump" : "highp", // 低配设备降低精度
          preserveDrawingBuffer: false,
          stencil: false,
          depth: true
        };
        
        try {
          renderer = new THREE.WebGLRenderer(rendererParams);
        } catch (e) {
          renderer = new THREE.WebGLRenderer({ antialias: false, precision: "mediump" });
        }
        
        // 性能优化：限制渲染分辨率
        const renderScale = isLowEndDevice ? 0.8 : 1.0;
        renderer.setSize(window.innerWidth * renderScale, window.innerHeight * renderScale);
        renderer.domElement.style.width = `${window.innerWidth}px`;
        renderer.domElement.style.height = `${window.innerHeight}px`;
        
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isLowEndDevice ? 1 : 1.5));
        renderer.autoClear = true;
        renderer.autoClearColor = true;
        renderer.autoClearDepth = true;
        renderer.autoClearStencil = true;
        
        document.getElementById('container').appendChild(renderer.domElement);

        updateLoadProgress(50);
        // 兼容OrbitControls的不同挂载方式
        const OrbitControls = window.OrbitControls || THREE.OrbitControls;
        try {
          controls = OrbitControls ? new OrbitControls(camera, renderer.domElement) : { update: () => {} };
        } catch (e) {
          controls = { update: () => {} };
        }
        
        // 性能优化：控制器降速，减少计算
        controls.enableDamping = !isLowEndDevice;
        controls.dampingFactor = 0.05;
        controls.minDistance = 50;
        controls.maxDistance = 100;
        controls.enableRotate = true;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.rotateSpeed = isLowEndDevice ? 0.5 : 0.8;
        controls.zoomSpeed = isLowEndDevice ? 0.8 : 1.0;

        updateLoadProgress(60);
        // 性能优化：减少灯光数量，降低计算
        const ambientLight = new THREE.AmbientLight(0xffffff, isLowEndDevice ? 1.5 : 2.0);
        scene.add(ambientLight);

        updateLoadProgress(70);
        // 性能优化：低配设备减少星星数量
        function createStars() {
          try {
            const starsCount = isLowEndDevice ? 1000 : 3000;
            const starsGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starsCount * 3);
            
            for (let i = 0; i < starsCount * 3; i += 3) {
              positions[i] = (Math.random() - 0.5) * 1500;
              positions[i + 1] = (Math.random() - 0.5) * 1500;
              positions[i + 2] = (Math.random() - 0.5) * 1500;
            }
            
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starsMaterial = new THREE.PointsMaterial({
              color: 0xffffff,
              size: isLowEndDevice ? 0.6 : 0.9,
              sizeAttenuation: true,
              opacity: 0.6
            });
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
          } catch (e) {
            console.log('星空创建失败:', e);
          }
        }
        createStars();

        updateLoadProgress(80);
        // 性能优化：分批初始化文字，避免主线程阻塞
        let initCount = 0;
        const batchInit = () => {
          const batchSize = isLowEndDevice ? 5 : 10;
          for (let i = 0; i < batchSize && initCount < config.maxActiveText; i++) {
            createSingleText();
            initCount++;
            updateLoadProgress(80 + (initCount / config.maxActiveText) * 20);
          }
          
          if (initCount < config.maxActiveText) {
            requestIdleCallback(batchInit, { timeout: 100 });
          } else {
            updateLoadProgress(100);
          }
        };
        batchInit();

        // 性能优化：调整定时器频率
        setInterval(throttledSpawnNewText, config.spawnInterval);
        setInterval(batchDeleteText, isLowEndDevice ? 100 : 50); // 批量删除节流

        // 窗口适配（性能优化：节流resize）
        const throttledResize = throttle(onWindowResize, 200);
        window.addEventListener('resize', throttledResize);
      }

      // 窗口大小适配
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        
        const renderScale = isLowEndDevice ? 0.8 : 1.0;
        renderer.setSize(window.innerWidth * renderScale, window.innerHeight * renderScale);
        renderer.domElement.style.width = `${window.innerWidth}px`;
        renderer.domElement.style.height = `${window.innerHeight}px`;
      }

      // 性能优化：帧率控制（低配设备降帧）
      let lastFrameTime = 0;
      const targetFps = isLowEndDevice ? 30 : 60;
      const frameInterval = 1000 / targetFps;

      // 核心动画循环（深度性能优化+颜色统一）
      function animate(timestamp) {
        // 帧率控制
        if (timestamp - lastFrameTime < frameInterval) {
          requestAnimationFrame(animate);
          return;
        }
        lastFrameTime = timestamp;

        // 第一步：统一更新全局颜色（所有文字基于此更新）
        updateGlobalRGB();

        // 第二步：批量更新所有文字（确保颜色统一）
        for (let i = textMeshes.length - 1; i >= 0; i--) {
          const mesh = textMeshes[i];
          
          // 1. 统一更新位置（速度已翻倍）
          mesh.position.y += mesh.userData.speed;

          // 2. 统一更新颜色（区分纹理文字和兜底方块）
          if (mesh.userData.ctx && mesh.userData.text) {
            // 纹理文字：使用全局颜色字符串更新
            const { ctx, canvas, text, fontSize } = mesh.userData;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = `bold ${fontSize}px Microsoft Yahei`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = globalColorStr; // 统一使用全局颜色
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            mesh.material.map.needsUpdate = true;
          } else {
            // 兜底方块：使用全局Three.Color对象更新
            mesh.material.color.copy(globalThreeColor); // 统一复制全局颜色
            mesh.material.needsUpdate = true;
          }
        }

        // 第三步：控制器更新（仅在需要时）
        if (controls.enableDamping) {
          controls.update();
        }

        // 第四步：渲染场景
        renderer.render(scene, camera);

        requestAnimationFrame(animate);
      }

      // 初始化入口
      function init() {
        const timeoutTimer = setTimeout(() => {
          if (loadProgress < 100) {
            loadingTextEl.textContent = "加载超时，重试中...";
            updateLoadProgress(0);
            setTimeout(() => { initScene(); }, 1000);
          }
        }, loadTimeout);

        if (!checkWebGL()) {
          clearTimeout(timeoutTimer);
          loadingEl.style.display = 'none';
          webglErrorEl.style.display = 'flex';
          errorDetailEl.textContent = "当前设备/浏览器不支持WebGL，请更换Chrome/Edge/Firefox浏览器重试";
          return;
        }

        try {
          initScene();
          requestAnimationFrame(animate);
          clearTimeout(timeoutTimer);
        } catch (e) {
          clearTimeout(timeoutTimer);
          console.error('初始化失败:', e);
          loadingEl.style.display = 'none';
          webglErrorEl.style.display = 'flex';
          errorDetailEl.textContent = `场景初始化失败：${e.message}`;
        }
      }

      // 执行初始化
      init();
    }

    // 页面加载完成后，先预加载Three.js，再初始化3D
    window.addEventListener('DOMContentLoaded', async () => {
      const loadingEl = document.getElementById('loading');
      const webglErrorEl = document.getElementById('webgl-error');
      const errorDetailEl = document.getElementById('error-detail');
      const loadingTextEl = loadingEl.querySelector('.loading-text');
      
      try {
        // 预加载Three.js（带重试+多CDN）
        loadingTextEl.textContent = "正在加载3D资源...";
        await window.preloadThree();
        
        // 检查Three.js是否可用
        if (!window.THREE || !THREE.Scene) {
          throw new Error('Three.js核心未加载成功');
        }
        
        // 初始化3D场景
        init3D();
      } catch (error) {
        console.error('加载失败:', error);
        loadingEl.style.display = 'none';
        webglErrorEl.style.display = 'flex';
        errorDetailEl.textContent = `加载失败：${error.message}，请刷新页面或更换网络重试`;
      }
    });

    // 性能优化：页面隐藏时暂停动画，恢复时重启
    let animationId;
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        cancelAnimationFrame(animationId);
      } else {
        animationId = requestAnimationFrame(animate);
      }
    });
  </script>
</body>
</html>