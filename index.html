<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Pragma" content="no-cache">
  <!-- 视口配置：禁止缩放，基础尺寸适配 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>祝你前程似锦~</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://res2.wx.qq.com/open/js/jweixin-1.6.0.js"></script>
  <style>
    /* 全局样式：页面背景，居中容器 */
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
      overflow: hidden !important;
    }
    html, body {
      width: 100vw !important;
      height: 100vh !important;
      margin: 0 !important;
      padding: 0 !important;
      overflow: hidden !important;
      touch-action: none !important;
      zoom: 1 !important;
      background: #111; /* 页面背景色，可自定义 */
      font-family: "Microsoft Yahei", PingFang SC, sans-serif;
      /* 核心：让body作为容器，居中750×698的渲染窗口 */
      display: flex;
      justify-content: center;
      align-items: center;
    }
    /* 核心：750×698渲染容器，居中显示 */
    #container { 
      width: 750px !important; 
      height: 698px !important;
      position: relative !important;
      z-index: 1;
      border: 1px solid #333; /* 可选：显示容器边框，便于查看 */
      box-shadow: 0 0 20px rgba(0,0,0,0.5); /* 可选：增加阴影，突出窗口 */
    }
    /* 加载提示：居中在容器内 */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 18px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .loading-progress {
      font-size: 14px;
      color: #ccc;
    }
    #webgl-error {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      text-align: center;
      z-index: 9999;
      display: none;
    }
    #webgl-error p {
      margin-top: 20px;
      line-height: 1.6;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="loading">
      <div class="loading-spinner"></div>
      <div class="loading-text">正在加载3D场景...</div>
      <div class="loading-progress">0%</div>
    </div>
    <div id="webgl-error">
      <h3>当前设备/浏览器不支持WebGL</h3>
      <p>请更换Chrome/Edge/Firefox浏览器，或使用微信内置浏览器打开</p>
    </div>
  </div>

  <!-- 1. 微信字体适配 -->
  <script>
    (function() {
      function handleFontSize() {
        try {
          if (window.WeixinJSBridge) {
            WeixinJSBridge.invoke("setFontSizeCallback", { fontSize: 0 });
            WeixinJSBridge.on("menu:setfont", () => {
              WeixinJSBridge.invoke("setFontSizeCallback", { fontSize: 0 });
            });
          }
        } catch (e) { /* 非微信环境忽略报错 */ }
      }

      if (window.WeixinJSBridge) {
        handleFontSize();
      } else {
        document.addEventListener("WeixinJSBridgeReady", handleFontSize, false);
      }
    })();
  </script>

  <!-- 2. 防缩放/防滚动 -->
  <script>
    window.onload = function() {
      // 阻止双击缩放
      let lastTouchEnd = 0;
      document.addEventListener("touchend", (event) => {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) event.preventDefault();
        lastTouchEnd = now;
      }, { passive: false });

      // 阻止多点触控
      document.addEventListener("touchstart", (event) => {
        if (event.touches.length > 1) event.preventDefault();
      }, { passive: false });

      // 阻止键盘缩放
      document.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=' || e.wheelDelta)) {
          e.preventDefault();
        }
      });

      // 阻止滚轮缩放
      document.addEventListener("wheel", (e) => {
        if (e.ctrlKey) e.preventDefault();
      }, { passive: false });

      // 锁定容器尺寸，防止篡改
      const observer = new MutationObserver((mutations) => {
        mutations.forEach(() => {
          document.getElementById('container').style.width = '750px';
          document.getElementById('container').style.height = '698px';
        });
      });
      observer.observe(document.getElementById('container'), { attributes: true, attributeFilter: ['style'] });
    };
  </script>

  <!-- 3. 核心3D逻辑（适配750×698居中容器） -->
  <script>
    function waitForThreeLoaded() {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (window.THREE && window.THREE.Scene) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
        setTimeout(() => {
          clearInterval(checkInterval);
          reject(new Error("Three.js库加载超时"));
        }, 10000);
      });
    }

    async function init3D() {
      let scene, camera, renderer, controls;
      const textMeshes = [];
      const textList = ["学业有成", "步履不停", "奔赴山海", "未来可期", "前程似锦"];
      let currentRGB = { r: 255, g: 0, b: 0 };
      let colorPhase = 0;

      const config = {
        centerRatio: 0.8,
        centerXRange: { min: -20, max: 20 },
        sideXRange: { min: -40, max: 40 },
        zRange: { min: -45, max: 5 },
        maxActiveText: 80,
        minActiveText: 75,
        spawnInterval: 50,
        deleteYThreshold: 75,
        fontSize: {
          small: { min: 50, max: 80, weight: 0.6 },
          medium: { min: 80, max: 110, weight: 0.3 },
          large: { min: 110, max: 140, weight: 0.1 }
        },
        geoSize: {
          small: { min: 15, max: 30, weight: 0.6 },
          medium: { min: 30, max: 40, weight: 0.3 },
          large: { min: 40, max: 50, weight: 0.1 }
        },
        centerSpeedRange: { min: 0.3, max: 0.6 },
        sideSpeedRange: { min: 0.2, max: 0.25 },
        colorSpeed: 0.004
      };

      const containerEl = document.getElementById('container');
      const loadingEl = document.getElementById('loading');
      const loadingTextEl = loadingEl.querySelector('.loading-text');
      const loadingProgressEl = loadingEl.querySelector('.loading-progress');
      const webglErrorEl = document.getElementById('webgl-error');
      let loadProgress = 0;
      const loadTimeout = 10000;

      const colorGradients = [
        { r: 255, g: 0, b: 0 },
        { r: 255, g: 127, b: 0 },
        { r: 255, g: 255, b: 0 },
        { r: 0, g: 255, b: 0 },
        { r: 0, g: 255, b: 255 },
        { r: 0, g: 0, b: 255 },
        { r: 127, g: 0, b: 255 },
        { r: 255, g: 0, b: 0 }
      ];

      function checkWebGL() {
        try {
          const canvas = document.createElement('canvas');
          return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
        } catch (e) {
          return false;
        }
      }

      function updateLoadProgress(progress) {
        loadProgress = Math.min(progress, 100);
        loadingProgressEl.textContent = `${loadProgress}%`;
        if (loadProgress >= 100) {
          loadingEl.style.opacity = 0;
          setTimeout(() => { loadingEl.style.display = 'none'; }, 500);
        }
      }

      function getCenterBiasedX(isCenter) {
        if (isCenter) {
          return Math.random() * (config.centerXRange.max - config.centerXRange.min) + config.centerXRange.min;
        } else {
          const sideX = Math.random() * (config.sideXRange.max - config.sideXRange.min) + config.sideXRange.min;
          return sideX > config.centerXRange.min && sideX < config.centerXRange.max 
            ? (sideX < 0 ? config.centerXRange.min - 3 : config.centerXRange.max + 3) 
            : sideX;
        }
      }

      function getSizeType() {
        const random = Math.random();
        return random < 0.6 ? 'small' : random < 0.9 ? 'medium' : 'large';
      }

      function getRandomFontSize() {
        const type = getSizeType();
        const range = config.fontSize[type];
        return Math.floor(Math.random() * (range.max - range.min + 1) + range.min);
      }

      function getRandomGeoSize() {
        const type = getSizeType();
        const range = config.geoSize[type];
        return Math.round(Math.random() * (range.max - range.min) * 10) / 10 + range.min;
      }

      function getRandomSpeed(isCenter, geoSize) {
        const speedFactor = 1 - (geoSize - config.geoSize.small.min) / (config.geoSize.large.max - config.geoSize.small.min);
        const [min, max] = isCenter ? [config.centerSpeedRange.min, config.centerSpeedRange.max] : [config.sideSpeedRange.min, config.sideSpeedRange.max];
        return min + (max - min) * speedFactor * Math.random();
      }

      function getRandomZ() { return Math.random() * (config.zRange.max - config.zRange.min) + config.zRange.min; }
      function getRandomY() { return Math.random() * -180; }
      function getRandomText() { return textList[Math.floor(Math.random() * textList.length)]; }
      function isCenterText() { return Math.random() < config.centerRatio; }

      function updateGlobalRGB() {
        colorPhase = (colorPhase + config.colorSpeed) % 1;
        const gradientIndex = Math.floor(colorPhase * (colorGradients.length - 1));
        const nextIndex = (gradientIndex + 1) % (colorGradients.length - 1);
        const blend = colorPhase * (colorGradients.length - 1) - gradientIndex;
        const from = colorGradients[gradientIndex];
        const to = colorGradients[nextIndex];
        currentRGB.r = Math.floor(from.r + blend * (to.r - from.r));
        currentRGB.g = Math.floor(from.g + blend * (to.g - from.g));
        currentRGB.b = Math.floor(from.b + blend * (to.b - from.b));
      }

      function createTextTexture(text, fontSize) {
        const canvasWidth = fontSize * text.length * 2.2;
        const canvasHeight = fontSize * 2.8;
        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold ${fontSize}px Microsoft Yahei`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = `rgb(${currentRGB.r}, ${currentRGB.g}, ${currentRGB.b})`;
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        return { texture, canvas, ctx };
      }

      function createSingleText() {
        const isCenter = isCenterText();
        const text = getRandomText();
        const fontSize = getRandomFontSize();
        const geoWidth = getRandomGeoSize();
        const geoHeight = geoWidth / 4;

        try {
          const textureData = createTextTexture(text, fontSize);
          const material = new THREE.MeshBasicMaterial({
            map: textureData.texture,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide,
            alphaTest: 0.01,
            blending: THREE.NormalBlending
          });
          const geometry = new THREE.PlaneGeometry(geoWidth, geoHeight);
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(getCenterBiasedX(isCenter), getRandomY(), getRandomZ());
          mesh.userData = { isCenter, speed: getRandomSpeed(isCenter, geoWidth), text, canvas: textureData.canvas, ctx: textureData.ctx, fontSize, geoWidth, geoHeight };
          scene.add(mesh);
          textMeshes.push(mesh);
          return mesh;
        } catch (e) {
          const material = new THREE.MeshBasicMaterial({
            color: new THREE.Color(currentRGB.r / 255, currentRGB.g / 255, currentRGB.b / 255),
            transparent: true,
            opacity: 1
          });
          const geometry = new THREE.PlaneGeometry(geoWidth, geoHeight);
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(getCenterBiasedX(isCenter), getRandomY(), getRandomZ());
          mesh.userData = { isCenter, speed: getRandomSpeed(isCenter, geoWidth), text, fontSize, geoWidth, geoHeight };
          scene.add(mesh);
          textMeshes.push(mesh);
          return mesh;
        }
      }

      function spawnNewText() {
        const needAdd = config.maxActiveText - textMeshes.length;
        if (needAdd > 0) {
          for (let i = 0; i < Math.min(needAdd, 8); i++) createSingleText();
        }
      }

      function deleteText(mesh) {
        const index = textMeshes.indexOf(mesh);
        if (index > -1) {
          textMeshes.splice(index, 1);
          scene.remove(mesh);
          if (mesh.geometry) mesh.geometry.dispose();
          if (mesh.material) {
            if (mesh.material.map) mesh.material.map.dispose();
            mesh.material.dispose();
          }
        }
      }

      function initScene() {
        updateLoadProgress(20);
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        updateLoadProgress(30);
        // 严格匹配750×698比例的相机
        camera = new THREE.PerspectiveCamera(58, 750 / 698, 0.1, 1000);
        camera.position.set(0, 0, 55);

        updateLoadProgress(40);
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: "high-performance"
        });
        // 强制渲染尺寸为750×698
        renderer.setSize(750, 698);
        renderer.setPixelRatio(window.devicePixelRatio || 1); // 适配高清屏，渲染尺寸仍为750×698
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        containerEl.appendChild(renderer.domElement);

        updateLoadProgress(50);
        const OrbitControls = window.OrbitControls || THREE.OrbitControls;
        controls = OrbitControls ? new OrbitControls(camera, renderer.domElement) : { update: () => {} };
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 45;
        controls.maxDistance = 95;

        updateLoadProgress(60);
        scene.add(new THREE.AmbientLight(0xffffff, 2.0));

        updateLoadProgress(70);
        // 星空背景
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 3000;
        const positions = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount * 3; i += 3) {
          positions[i] = (Math.random() - 0.5) * 1400;
          positions[i + 1] = (Math.random() - 0.5) * 1400;
          positions[i + 2] = (Math.random() - 0.5) * 1400;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const starsMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.9,
          sizeAttenuation: true,
          opacity: 0.6
        });
        scene.add(new THREE.Points(starsGeometry, starsMaterial));

        updateLoadProgress(80);
        for (let i = 0; i < config.maxActiveText; i++) {
          createSingleText();
          updateLoadProgress(80 + (i + 1) * 0.25);
        }

        updateLoadProgress(100);
        setInterval(spawnNewText, config.spawnInterval);
        setInterval(() => { if (textMeshes.length < config.minActiveText) spawnNewText(); }, 30);
      }

      function animate() {
        requestAnimationFrame(animate);
        updateGlobalRGB();

        // 批量处理文字
        for (let i = textMeshes.length - 1; i >= 0; i--) {
          const mesh = textMeshes[i];
          if (mesh.userData.ctx && mesh.userData.text) {
            const { ctx, canvas, text, fontSize } = mesh.userData;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = `bold ${fontSize}px Microsoft Yahei`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = `rgb(${currentRGB.r}, ${currentRGB.g}, ${currentRGB.b})`;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            mesh.material.map.needsUpdate = true;
          } else {
            mesh.material.color.setRGB(currentRGB.r / 255, currentRGB.g / 255, currentRGB.b / 255);
          }

          mesh.position.y += mesh.userData.speed;
          if (mesh.position.y > config.deleteYThreshold) deleteText(mesh);
        }

        controls.update();
        renderer.render(scene, camera);
      }

      // 初始化执行
      const timeoutTimer = setTimeout(() => {
        if (loadProgress < 100) {
          loadingTextEl.textContent = "加载超时，重试中...";
          updateLoadProgress(0);
          setTimeout(initScene, 1000);
        }
      }, loadTimeout);

      if (!checkWebGL()) {
        clearTimeout(timeoutTimer);
        loadingEl.style.display = 'none';
        webglErrorEl.style.display = 'flex';
        return;
      }

      try {
        initScene();
        animate();
        clearTimeout(timeoutTimer);
      } catch (e) {
        clearTimeout(timeoutTimer);
        console.error('初始化失败:', e);
        loadingEl.style.display = 'none';
        webglErrorEl.innerHTML = `<h3>场景加载失败</h3><p>错误信息：${e.message}</p>`;
        webglErrorEl.style.display = 'flex';
      }
    }

    // 页面加载完成后初始化3D
    window.addEventListener('DOMContentLoaded', async () => {
      const loadingEl = document.getElementById('loading');
      const webglErrorEl = document.getElementById('webgl-error');
      try {
        await waitForThreeLoaded();
        init3D();
      } catch (error) {
        console.error('Three.js加载失败:', error);
        loadingEl.style.display = 'none';
        webglErrorEl.innerHTML = `<h3>3D库加载失败</h3><p>请检查网络或刷新页面重试</p><p>错误：${error.message}</p>`;
        webglErrorEl.style.display = 'flex';
      }
    });
  </script>
</body>
</html>